<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>LTE KPI Dashboard</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.6.2/fuse.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/pptxgenjs@3.12.0/dist/pptxgen.bundle.js"></script>

<style>
/* --- BASE STYLES --- */
body { font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin:0; padding:0; background:#f4f7f6; overflow-x:hidden; }
header { text-align:center; padding:15px 0; font-size:28px; font-weight:700; color:#333; background:white; box-shadow:0 2px 4px rgba(0,0,0,0.05); margin-bottom:15px; }

/* --- NAVIGATION --- */
.navbar { display:flex; justify-content:center; gap:12px; margin-bottom:15px; }
.nav-btn { padding:8px 24px; cursor:pointer; border:1px solid #ccc; background:white; color:#555; border-radius:20px; font-weight:600; text-decoration:none; transition:0.2s; display:inline-block; }
.nav-btn:hover { background:#f0f0f0; color:#333; }
.nav-btn.active { background:#2F80ED; color:white; border-color:#2F80ED; }

/* --- TABS --- */
.tabs { display:flex; justify-content:center; margin-bottom:20px; gap:8px; }
.tab { padding:8px 20px; cursor:pointer; border-radius:6px; background:#e0e0e0; color:#555; font-weight:bold; border:none; transition:0.2s; }
.tab:hover { background:#d0d0d0; }
.tab.active { background:#2F80ED; color:white; }

/* --- CONTROLS --- */
.controls { display:flex; justify-content:center; gap:10px; margin-bottom:20px; flex-wrap:wrap; align-items:center; }
.control-group { position:relative; }
input, select { padding:8px; border-radius:6px; border:1px solid #ccc; font-size:14px; outline:none; }
button.action-btn { padding:8px 16px; cursor:pointer; border:none; background:#2F80ED; color:white; border-radius:6px; font-weight:600; transition:0.2s; }
button.action-btn:hover { background:#1f5ab5; }
button.ppt-btn { background:#D24726; } /* PowerPoint Orange */
button.ppt-btn:hover { background:#a8381e; }

/* --- CHART STYLE SELECTOR (Inside Style Drawer) --- */
.style-options { 
    display: flex; 
    flex-direction: column; 
    gap: 5px; 
    margin-top: 5px;
}
.style-options button {
    background: #f0f0f0;
    color: #333;
    padding: 6px 10px;
    border: 1px solid #ddd;
    text-align: left;
}
.style-options button.active {
    background: #2F80ED;
    color: white;
    border-color: #2F80ED;
}


/* --- GRID LAYOUT (3 Graphs per row) --- */
.chart-grid { 
  display:grid; 
  grid-template-columns: repeat(3, 1fr); 
  gap:20px; 
  padding:0 20px 40px 20px; 
  max-width: 1800px; 
  margin: 0 auto; 
}
@media (max-width: 1400px) { .chart-grid { grid-template-columns: repeat(2, 1fr); } }
@media (max-width: 768px) { .chart-grid { grid-template-columns: 1fr; } }

/* --- CARDS & CHARTS --- */
.chart-card { background:white; border-radius:8px; padding:15px; box-shadow:0 2px 8px rgba(0,0,0,0.08); display:flex; flex-direction:column; }
.chart-title { display:none; } 
.chart-container { position: relative; height: 280px; width: 100%; }

/* --- DROPDOWNS --- */
#dropdown, #siteDropdownList, #onAirDateDropdownList { 
  position:absolute; 
  background:white; 
  border:1px solid #ccc; 
  max-height:200px; 
  overflow-y:auto; 
  display:none; 
  z-index:100; 
  width:100%; 
  top:105%; 
  border-radius:6px; 
  box-shadow:0 4px 10px rgba(0,0,0,0.1); 
}
#dropdown div, #siteDropdownList div, #onAirDateDropdownList div { padding:6px 10px; cursor:pointer; font-size:13px; border-bottom:1px solid #eee; }
#dropdown div:hover, #siteDropdownList div:hover, #onAirDateDropdownList div:hover { background:#f0f7ff; color:#2F80ED; }

/* --- DRAWER STYLES (KPI and Style) --- */
/* Base Toggle Button Style */
.drawerToggle { 
    position:fixed; 
    width:36px; 
    height:36px; 
    background:#2F80ED; 
    color:white; 
    border-radius:6px 0 0 6px; 
    cursor:pointer; 
    display:flex; 
    align-items:center; 
    justify-content:center; 
    font-size:20px; 
    z-index:900; 
    transition: right 0.3s; 
}
/* Positioning for Style button (top) */
.styleDrawerToggle { right:0; top:100px; } 

/* Positioning for KPI button (bottom) */
.kpiDrawerToggle { right:0; top:145px; } 

/* Base Drawer Style */
.drawer { 
  position:fixed; top:0; right:0; 
  width:320px; 
  height:100%; background:white; 
  box-shadow:-2px 0 10px rgba(0,0,0,0.1); z-index:1000; 
  transform:translateX(100%); transition:0.3s; padding:20px; 
  display: flex; flex-direction: column; 
}
.drawer.open { transform:translateX(0); }

/* Adjustments when drawers are open (both buttons move out of the way) */
#kpiDrawer.open ~ .styleDrawerToggle { right: 320px; }
#kpiDrawer.open ~ .kpiDrawerToggle { right: 320px; } 

/* The style drawer opens on top and pushes both buttons */
#styleDrawer { z-index: 1001; }
#styleDrawer.open ~ .kpiDrawerToggle { right: 320px; }
#styleDrawer.open ~ .styleDrawerToggle { right: 320px; }


.drawer-header { 
    display: flex; 
    justify-content: space-between; 
    align-items: center; 
    margin-bottom: 10px; 
    padding-bottom: 10px; 
    border-bottom: 1px solid #eee; 
    flex-shrink: 0;
}
.drawer-header h3 { margin: 0; }
.drawer-controls { 
    display: flex; 
    gap: 5px; 
    align-items: center; 
}
.drawer-controls .action-btn { 
    padding: 6px 10px; 
    font-size: 13px; 
}
.drawer-body { flex-grow: 1; overflow-y: auto; padding-right: 5px; padding-bottom: 40px; } 

/* --- PREVIEW MODAL --- */
.modal { position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.6); z-index:2000; display:none; align-items:center; justify-content:center; backdrop-filter:blur(3px); }
.modal-content { 
    background:white; 
    width:95%; 
    max-width: 1400px; 
    height:90vh; 
    border-radius:12px; 
    display:flex; 
    flex-direction:column; 
    box-shadow:0 10px 25px rgba(0,0,0,0.3); 
}
.modal-header { padding:15px 20px; border-bottom:1px solid #eee; display:flex; justify-content:space-between; align-items:center; font-weight:bold; font-size:18px; }
.modal-body { flex:1; display: flex; padding:0; overflow: hidden; } 

/* Preview Side */
#previewBody { 
    flex: 1; 
    overflow-y:auto; 
    padding:20px; 
    background:#f5f5f5; 
}
.preview-slide { background:white; border:1px solid #ddd; margin-bottom:20px; padding:20px; box-shadow:0 2px 5px rgba(0,0,0,0.05); aspect-ratio: 16/9; position:relative; }
.preview-slide-title { position:absolute; top:10px; left:20px; font-size:16px; font-weight:bold; color:#D24726; }
.preview-grid { display:grid; height:100%; align-items:center; padding-top:30px; }
.preview-img-box { text-align:center; padding:5px; height:100%; display:flex; flex-direction:column; justify-content:center; }
.preview-img-box img { max-width:100%; max-height:calc(100% - 20px); object-fit:contain; border:1px solid #eee; }
.preview-label { display: none; } 

/* Settings Side (Fixed, not scrollable) */
#previewSettingsPanel {
    width: 250px;
    background: #fff;
    border-left: 1px solid #eee;
    padding: 20px;
    display: flex;
    flex-direction: column;
    flex-shrink: 0; 
}
.settings-group { margin-bottom: 20px; }
.settings-group h4 { margin-top: 0; margin-bottom: 10px; font-size: 14px; color: #555; border-bottom: 1px solid #eee; padding-bottom: 5px; }
.graph-options button { margin: 5px; width: 100px; padding: 6px; font-size: 13px; }

/* Color Selector */
.color-option { margin: 5px; display: inline-block; cursor: pointer; border: 2px solid transparent; border-radius: 50%; width: 25px; height: 25px; transition: border 0.1s; }
.color-option.selected { border-color: #333; }

.modal-footer { 
    padding:15px 20px; 
    border-top:1px solid #eee; 
    text-align:right;
    flex-shrink: 0; 
}
</style>
</head>
<body onload="fetchData()">

<header>LTE KPI Dashboard</header>

<div class="navbar">
  <a href="gsm.html" class="nav-btn">GSM</a>
  <a href="index.html" class="nav-btn active">LTE</a>
  <a href="nr.html" class="nav-btn">NR</a>
</div>

<div class="tabs">
  <button class="tab active" onclick="switchTab('both')">All KPIs (Both)</button> 
  <button class="tab" onclick="switchTab('acceptance')">Acceptance</button>
  <button class="tab" onclick="switchTab('monitoring')">Monitoring</button>
</div>

<div class="controls">
  <div class="control-group" style="width:200px;">
    <button id="onAirDateDropdownBtn" class="action-btn" style="background:white; color:#333; border:1px solid #ccc; width:100%; text-align:left; display:flex; justify-content:space-between;">
      <span id="onAirDateBtnLabel">All On-Air Dates</span> <span>â–¼</span>
    </button>
    <div id="onAirDateDropdownList"></div>
  </div>

  <div class="control-group" style="width:200px;">
    <button id="siteDropdownBtn" class="action-btn" style="background:white; color:#333; border:1px solid #ccc; width:100%; text-align:left; display:flex; justify-content:space-between;">
      <span id="siteBtnLabel">All Sites</span> <span>â–¼</span>
    </button>
    <div id="siteDropdownList"></div>
  </div>

  <button onclick="fetchData()" class="action-btn">Refresh</button>
  <button onclick="openPreview()" class="action-btn ppt-btn">Export PPT</button>
</div>

<div class="chart-grid" id="mainChartContainer"></div>

<div class="styleDrawerToggle drawerToggle" onclick="toggleStyleDrawer()">ðŸŽ¨</div>
<div id="styleDrawer" class="drawer">
  <div class="drawer-header">
    <h3>Chart Style Settings</h3>
    <button onclick="toggleStyleDrawer()" style="border:none; background:none; font-size:24px; cursor:pointer; color:#777;">âœ•</button>
  </div>
  <div class="drawer-body">
    <h4>Chart Display Style (Select one)</h4>
    <div id="chartStyleOptions" class="style-options">
      </div>
    <p style="margin-top:20px; font-size:12px; color:#555;">Choose a style to adjust the line width, point size, smoothness, and background fill of the charts.</p>
  </div>
</div>

<div class="kpiDrawerToggle drawerToggle" onclick="toggleKpiDrawer()">âš™</div>
<div id="kpiDrawer" class="drawer">
  <div class="drawer-header">
    <h3>KPI Visibility Settings</h3>
    <div class="drawer-controls">
        <button class="action-btn" onclick="selectVisibleKpis()" style="background:#5cb85c;">Select All</button>
        <button class="action-btn" onclick="clearVisibleKpis()" style="background:#f0ad4e;">Clear All</button>
        <button class="action-btn" onclick="applyKpis()">Apply</button>
        <button onclick="toggleKpiDrawer()" style="border:none; background:none; font-size:24px; cursor:pointer; color:#777;">âœ•</button>
    </div>
  </div>
  <div class="drawer-body" id="kpiOptionsList">
    </div>
</div>


<div id="previewModal" class="modal">
  <div class="modal-content">
    <div class="modal-header">
      <span id="previewTitle">PPT Export Preview</span>
      <button onclick="closePreview()" style="border:none; background:none; font-size:20px; cursor:pointer;">âœ•</button>
    </div>
    <div class="modal-body">
        
        <div id="previewBody">
          </div>

        <div id="previewSettingsPanel">
            <h3>Export Settings</h3>

            <div class="settings-group">
                <h4>Graphs per Slide (Rows)</h4>
                <div class="graph-options">
                    <button class="action-btn" data-count="1" onclick="updatePreviewSettings(1, chartExportColor, chartExportTitleColor)">1 Graph</button>
                    <button class="action-btn" data-count="2" onclick="updatePreviewSettings(2, chartExportColor, chartExportTitleColor)">2 Graphs</button>
                    <button class="action-btn" data-count="3" onclick="updatePreviewSettings(3, chartExportColor, chartExportTitleColor)">3 Graphs</button>
                    <button class="action-btn" data-count="4" onclick="updatePreviewSettings(4, chartExportColor, chartExportTitleColor)">4 Graphs</button>
                    <button class="action-btn" data-count="6" onclick="updatePreviewSettings(6, chartExportColor, chartExportTitleColor)">6 Graphs</button>
                    <button class="action-btn" data-count="9" onclick="updatePreviewSettings(9, chartExportColor, chartExportTitleColor)">9 Graphs</button>
                </div>
            </div>

            <div class="settings-group">
                <h4>Line & Dot Color for PPT</h4>
                <div id="lineColorOptions">
                    <span class="color-option" style="background-color:#2F80ED;" data-color="#2F80ED" onclick="updatePreviewSettings(graphsPerSlide, '#2F80ED', chartExportTitleColor)"></span>
                    <span class="color-option" style="background-color:#27AE60;" data-color="#27AE60" onclick="updatePreviewSettings(graphsPerSlide, '#27AE60', chartExportTitleColor)"></span>
                    <span class="color-option" style="background-color:#D24726;" data-color="#D24726" onclick="updatePreviewSettings(graphsPerSlide, '#D24726', chartExportTitleColor)"></span>
                    <span class="color-option" style="background-color:#8E44AD;" data-color="#8E44AD" onclick="updatePreviewSettings(graphsPerSlide, '#8E44AD', chartExportTitleColor)"></span>
                    <span class="color-option" style="background-color:#F39C12;" data-color="#F39C12" onclick="updatePreviewSettings(graphsPerSlide, '#F39C12', chartExportTitleColor)"></span>
                </div>
            </div>

            <div class="settings-group">
                <h4>Chart Title Color for PPT</h4>
                <div id="titleColorOptions">
                    <span class="color-option" style="background-color:#333333;" data-color="#333333" onclick="updatePreviewSettings(graphsPerSlide, chartExportColor, '#333333')"></span>
                    <span class="color-option" style="background-color:#000000;" data-color="#000000" onclick="updatePreviewSettings(graphsPerSlide, chartExportColor, '#000000')"></span>
                    <span class="color-option" style="background-color:#2F80ED;" data-color="#2F80ED" onclick="updatePreviewSettings(graphsPerSlide, chartExportColor, '#2F80ED')"></span>
                    <span class="color-option" style="background-color:#8E44AD;" data-color="#8E44AD" onclick="updatePreviewSettings(graphsPerSlide, chartExportColor, '#8E44AD')"></span>
                    <span class="color-option" style="background-color:#D24726;" data-color="#D24726" onclick="updatePreviewSettings(graphsPerSlide, chartExportColor, '#D24726')"></span>
                </div>
            </div>

            <div style="margin-top: auto; padding-top: 15px; border-top: 1px solid #eee;">
                <p style="font-size: 12px; color: #777;">Preview updates instantly.</p>
            </div>
        </div>

    </div>
    <div class="modal-footer">
      <button class="action-btn" style="background:#888;" onclick="closePreview()">Cancel</button>
      <button class="action-btn ppt-btn" onclick="downloadPPT()">Download .PPTX</button>
    </div>
  </div>
</div>

<script>
// --- CONFIG & STATE ---
let allData = [];
let fuse = null;
let allSites = [];
let siteCutoverMap = {}; 
let allOnAirDates = [];
let selectedOnAirDates = [];

let selectedSites = [];
let currentTab = "both"; 
let graphsPerSlide = 2; 

let chartExportColor = '#2F80ED'; 
let chartExportTitleColor = '#333333'; 

// NEW: Expanded Chart Styles Configuration (10 styles total)
const chartStyles = {
  // RESTORED: This style is now set as the initial default
  'Default': { border: 2, pointRadius: 3, tension: 0.1, gridColor: '#eee', bgColor: 'white', titleColor: '#333', fill: false, stepped: false },
  // Your preferred non-filled style is still available
  'Line & Dot (Original)': { border: 2, pointRadius: 3, tension: 0.3, gridColor: '#f5f5f5', bgColor: 'white', titleColor: '#555', fill: false, stepped: false },
  'Minimalist': { border: 1, pointRadius: 2, tension: 0.3, gridColor: '#f5f5f5', bgColor: 'white', titleColor: '#555', fill: false, stepped: false },
  'Bright Dots': { border: 3, pointRadius: 4, tension: 0.2, gridColor: '#ddd', bgColor: 'white', titleColor: '#333', fill: false, stepped: false },
  'Smooth & Thin': { border: 1, pointRadius: 0, tension: 0.4, gridColor: '#f0f0f0', bgColor: 'white', titleColor: '#333', fill: false, stepped: false },
  'Bold Lines': { border: 4, pointRadius: 0, tension: 0.1, gridColor: '#eee', bgColor: 'white', titleColor: '#333', fill: false, stepped: false },
  'Area Fill (Light)': { border: 2, pointRadius: 3, tension: 0.3, gridColor: '#eee', bgColor: 'white', titleColor: '#333', fill: 'origin', alpha: 0.15, stepped: false },
  'Shadowed Line': { border: 3, pointRadius: 4, tension: 0.2, gridColor: '#f0f0f0', bgColor: 'white', titleColor: '#333', fill: 'origin', alpha: 0.25, stepped: false },
  'Stepped Line': { border: 2, pointRadius: 3, tension: 0.0, gridColor: '#eee', bgColor: 'white', titleColor: '#333', fill: false, stepped: true },
  'High Contrast': { border: 4, pointRadius: 5, tension: 0.0, gridColor: 'rgba(0,0,0,0.1)', bgColor: 'white', titleColor: '#000', fill: false, stepped: false },
  'Monochromatic': { border: 3, pointRadius: 3, tension: 0.2, gridColor: '#f5f5f5', bgColor: 'white', titleColor: '#333', fill: false, stepped: false }
};

// Initial style set to 'Default'
let selectedStyle = 'Default'; 

const acceptanceKpis = [
  "LTE RRC Setup Success Rate","ERAB Setup Success Rate","LTE Call Setup Success Rate","E-RAB Call Drop Rate",
  "CSFB Access Success Rate","LTE Intra Freq HO Success Rate","Intra-eNB HO Success Rate","Inter-eNBX2HO Success Rate",
  "Inter-eNBS1HO Success Rate","Max RRC Connected Ue","DL Data Total Volume (Gbyte)","UL Data Total Volume (Gbyte)",
  "E-RAB Setup Success Rate (VoIP)","Call Drop Rate (VoIP)","Intra-frequency Handover Out Success Rate(VoIP)",
  "Inter-frequency Handover Out Success Rate(VoIP)","SRVCC Success Rate (L2W)","SRVCC Success Rate (L2G)"
];
const monitoringKpis = [
  "Cell Availability Ratio","Average Latency Downlink (msecs)","DL PRB Utilization (%)","UL PRB Utilization (%)",
  "LTE DL - Cell Average Throughput (Mbit/s)","LTE UL - Cell Average Thoughput (Mbit/s)","LTE DL -USER Average Throughput (Mbit/s)",
  "LTE UL -USER Average Throughput (Mbit/s)","Downlink Packet Loss Rate (VoIP)","Uplink Packet Loss Rate (VoIP)",
  "VoLTE Traffic Erlang","VoLTE Traffic DL (MB)","VoLTE Traffic UL (MB)","DL BLER QCI1","UL BLER QCI1"
];
let selectedKpis = {
  acceptance: [...acceptanceKpis],
  monitoring: [...monitoringKpis]
};

// --- GLOBAL UTILITY FUNCTIONS ---

/**
 * Rounds a number up to the nearest clean scale (e.g., 3630 -> 4000, 1580 -> 1600).
 * @param {number} value - The dynamic Ymax value calculated.
 * @returns {number} The cleanly rounded Ymax.
 */
function roundUpToCleanScale(value) {
    if (value <= 20) return Math.ceil(value / 5) * 5;      // e.g., 18 -> 20
    if (value <= 100) return Math.ceil(value / 10) * 10;   // e.g., 85 -> 90
    if (value <= 200) return Math.ceil(value / 20) * 20;   // e.g., 165 -> 180
    if (value <= 500) return Math.ceil(value / 50) * 50;   // e.g., 360 -> 400
    if (value <= 1000) return Math.ceil(value / 100) * 100; // e.g., 750 -> 800
    if (value <= 2000) return Math.ceil(value / 200) * 200; // e.g., 1580 -> 1600 
    if (value <= 5000) return Math.ceil(value / 500) * 500; // e.g., 3630 -> 4000
    if (value <= 10000) return Math.ceil(value / 1000) * 1000;
    if (value <= 20000) return Math.ceil(value / 2000) * 2000;
    if (value <= 50000) return Math.ceil(value / 5000) * 5000;
    return Math.ceil(value / 10000) * 10000;
}

/**
 * Calculates the largest clean step size that guarantees at least 'minTicks' (e.g., 5) across a range.
 * A "clean" step is 1, 2, 5 multiplied by a power of 10.
 * @param {number} range - The total range (yMax - yMin).
 * @param {number} minTicks - The minimum number of ticks desired.
 * @returns {number} The calculated clean step size.
 */
function getIdealTickStep(range, minTicks = 5) {
    if (range <= 0) return 0.2; 

    // Ideal step size is range / (minTicks - 1)
    const targetSteps = minTicks - 1; // e.g., 4 steps for 5 ticks
    let idealStep = range / targetSteps;

    // Find the magnitude (power of 10) of the ideal step
    let power = Math.pow(10, Math.floor(Math.log10(idealStep)));
    
    // Check clean steps in descending order (5x, 2x, 1x magnitude)
    const cleanSteps = [5 * power, 2 * power, 1 * power];
    
    // Find the largest clean step that is less than or equal to the ideal step
    for (let step of cleanSteps) {
        // Use a small epsilon (1e-9) to handle floating point issues near the boundary
        if (step <= idealStep + 1e-9 && step > 0) {
            return step;
        }
    }
    
    // Fallback if idealStep is smaller than 1*power (e.g., ideal=0.08, power=0.1)
    let smallerPower = power / 10;
    
    // Check 5x the smaller magnitude (e.g., 0.05)
    if (5 * smallerPower > 0) {
        return 5 * smallerPower;
    }
    
    // Safety fallback for extremely tiny ranges
    return 0.1; 
}

/**
 * Converts a hex color string (e.g., #2F80ED) to an RGBA string with a specified opacity (alpha).
 * @param {string} hex - The hex color code.
 * @param {number} alpha - The desired opacity (0.0 to 1.0).
 * @returns {string} The RGBA color string.
 */
function hexToRgba(hex, alpha) {
    let r = 0, g = 0, b = 0;
    
    // 3 digits
    if (hex.length == 4) {
        r = parseInt(hex[1] + hex[1], 16);
        g = parseInt(hex[2] + hex[2], 16);
        b = parseInt(hex[3] + hex[3], 16);
    } 
    // 6 digits
    else if (hex.length == 7) {
        r = parseInt(hex[1] + hex[2], 16);
        g = parseInt(hex[3] + hex[4], 16);
        b = parseInt(hex[5] + hex[6], 16);
    }

    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

// --- DRAWER & STYLE FUNCTIONS ---

/**
 * Populates the style drawer with available options and sets the active state.
 */
function populateStyleOptions() {
    const container = document.getElementById('chartStyleOptions');
    container.innerHTML = '';

    Object.keys(chartStyles).forEach(styleName => {
        const btn = document.createElement('button');
        btn.textContent = styleName;
        btn.dataset.style = styleName;
        btn.onclick = () => updateChartStyle(styleName);
        
        if (styleName === selectedStyle) {
            btn.classList.add('active');
        }
        container.appendChild(btn);
    });
}

/**
 * Toggles the KPI drawer visibility.
 */
function toggleKpiDrawer(){
  const d = document.getElementById("kpiDrawer");
  const s = document.getElementById("styleDrawer");
  d.classList.toggle("open");
  if(d.classList.contains("open")) {
      populateKpiOptions();
      s.classList.remove("open"); // Close style drawer if KPI opens
  }
}

/**
 * Populates the KPI drawer with checkboxes based on current tab.
 */
function populateKpiOptions() {
    const list = document.getElementById("kpiOptionsList");
    list.innerHTML = "";
    
    let kpis = [];
    if(currentTab === "acceptance") kpis = acceptanceKpis;
    else if(currentTab === "monitoring") kpis = monitoringKpis;
    else if(currentTab === "both") kpis = [...acceptanceKpis, ...monitoringKpis];

    // Get the currently visible KPIs based on the combined list
    const currentVisibleKpis = [...selectedKpis.acceptance, ...selectedKpis.monitoring];

    kpis.forEach(kpi => {
        const d = document.createElement("div");
        const isChecked = currentVisibleKpis.includes(kpi);
        d.innerHTML = `<label><input type='checkbox' value='${kpi}' class='kpi-chk' ${isChecked ? "checked" : ""}> ${kpi}</label>`;
        list.appendChild(d);
    });
}

/**
 * Selects all KPIs in the drawer.
 */
function selectVisibleKpis() {
    document.querySelectorAll('#kpiOptionsList .kpi-chk').forEach(chk => chk.checked = true);
}

/**
 * Clears all KPI selections in the drawer.
 */
function clearVisibleKpis() {
    document.querySelectorAll('#kpiOptionsList .kpi-chk').forEach(chk => chk.checked = false);
}

/**
 * Applies the KPI selections from the drawer and re-renders charts.
 */
function applyKpis() {
    const checkedKpis = Array.from(document.querySelectorAll('#kpiOptionsList .kpi-chk:checked')).map(c => c.value);
    
    // Reset selectedKpis based on which tab the KPI belongs to
    selectedKpis.acceptance = checkedKpis.filter(kpi => acceptanceKpis.includes(kpi));
    selectedKpis.monitoring = checkedKpis.filter(kpi => monitoringKpis.includes(kpi));
    
    toggleKpiDrawer();
    renderCharts();
}


/**
 * Toggles the Chart Style drawer visibility.
 */
function toggleStyleDrawer(){
  const d = document.getElementById("styleDrawer");
  const k = document.getElementById("kpiDrawer");
  d.classList.toggle("open");
  if(d.classList.contains("open")) {
    populateStyleOptions();
    k.classList.remove("open"); // Close KPI drawer if Style opens
  }
}

/**
 * Updates the selected chart style and re-renders all charts.
 * @param {string} styleName - The name of the style from chartStyles.
 */
function updateChartStyle(styleName) {
    selectedStyle = styleName;
    // Visually update the button state
    document.querySelectorAll('.style-options button').forEach(btn => {
        btn.classList.remove('active');
        if (btn.dataset.style === styleName) {
            btn.classList.add('active');
        }
    });
    renderCharts();
}

/**
 * Switches the active tab (Acceptance, Monitoring, Both).
 * @param {string} tab - The tab identifier ('acceptance', 'monitoring', 'both').
 */
function switchTab(tab) {
    document.querySelectorAll('.tab').forEach(btn => {
        btn.classList.remove('active');
    });
    document.querySelector(`.tab[onclick="switchTab('${tab}')"]`).classList.add('active');
    currentTab = tab;
    // Repopulate options when switching tabs in case drawer is open
    if(document.getElementById("kpiDrawer").classList.contains("open")) {
        populateKpiOptions();
    }
    renderCharts(); 
}

// --- DATA FETCHING & MAPPING ---
async function fetchData(){
  try {
    // 1. Fetch KPI Data
    const kpiUrl = "https://docs.google.com/spreadsheets/d/e/2PACX-1vRIeWBt5CB8zpdFja0b3h2kodVsUrjD_PSHOkF93MkecZF04gWDoMXVq-q0REU-RvFQbjVggJVDLpUi/pub?gid=0&single=true&output=csv&t=" + Date.now();
    const kpiRes = await fetch(kpiUrl);
    const kpiText = await kpiRes.text();
    
    const kpiRows = kpiText.trim().split('\n').map(r=>r.split(','));
    const kpiHeaders = kpiRows.shift().map(h=>h.trim());
    allData = kpiRows.map(r=>{ 
      const obj={}; 
      kpiHeaders.forEach((h,i)=>{ 
        const val=r[i]?r[i].trim():""; 
        obj[h] = val==="" ? null : (isNaN(val) ? val : parseFloat(val)); 
      }); 
      return obj; 
    });

    // Determine all sites present in the KPI data
    allSites = [...new Set(allData.map(d=>d["eNodeB Name"]))].filter(s=>s).sort();

    // 2. Fetch Cutover Data
    const cutoverUrl = "https://docs.google.com/spreadsheets/d/e/2PACX-1vRIeWBt5CB8zpdFja0b3h2kodVsUrjD_PSHOkF93MkecZF04gWDoMXVq-q0REU-RvFQbjVggJVDLpUi/pub?gid=19616562&single=true&output=csv&t=" + Date.now();
    const cutoverRes = await fetch(cutoverUrl);
    const cutoverText = await cutoverRes.text();
    
    const cutoverRows = cutoverText.trim().split('\n').map(r=>r.split(','));
    const cutoverHeaders = cutoverRows.shift().map(h=>h.trim());
    
    siteCutoverMap = {};
    cutoverRows.forEach(r => {
        const siteName = r[cutoverHeaders.indexOf("eNodeB Name")]?.trim();
        const onAirDate = r[cutoverHeaders.indexOf("On-Air Date")]?.trim();
        if (siteName && onAirDate) {
            if (allSites.includes(siteName)) {
                 siteCutoverMap[siteName] = onAirDate;
            }
        }
    });

    // 3. Initialize Date Filter Options and State
    allOnAirDates = [...new Set(Object.values(siteCutoverMap))].filter(d => d).sort();
    selectedOnAirDates = [...allOnAirDates]; 
    selectedSites = []; 

    // 4. Update UI
    setupOnAirDateDropdown();
    setupSiteDropdown();
    renderCharts();

  } catch(e) { console.error(e); alert("Failed to load data."); }
}

// --- FILTER UI LOGIC (ON-AIR DATE) ---

function setupOnAirDateDropdown(){
  const list = document.getElementById("onAirDateDropdownList");
  const btn = document.getElementById("onAirDateDropdownBtn");
  list.innerHTML = "";
  
  const setAll = () => { 
    selectedOnAirDates = [...allOnAirDates]; 
    const allActiveSites = allSites.filter(site => siteCutoverMap[site] && allOnAirDates.includes(siteCutoverMap[site]));
    selectedSites = [...allActiveSites]; 

    updateDateFilterUI({close: false}); 
    setupSiteDropdown(); 
  };

  const clearAll = () => { 
    selectedOnAirDates = []; 
    selectedSites = []; 
    
    updateDateFilterUI({close: false}); 
    setupSiteDropdown(); 
  };
  
  // Actions
  list.innerHTML += `<div onclick="window.dateSetAll()"><b>Select All</b></div>`;
  list.innerHTML += `<div onclick="window.dateClearAll()"><b>Clear All</b></div>`;

  // Options
  allOnAirDates.forEach(date => {
    const d = document.createElement("div");
    const checked = selectedOnAirDates.includes(date) ? "checked" : "";
    d.innerHTML = `<input type='checkbox' value='${date}' class='date-chk' ${checked}> ${date}`;
    d.onclick = (e) => {
        if(e.target.tagName !== "INPUT") {
          const chk = d.querySelector("input");
          chk.checked = !chk.checked;
        }
        updateSelectedDates(); 
    };
    list.appendChild(d);
  });
  
  btn.onclick = () => list.style.display = list.style.display==="block" ? "none" : "block";
  
  window.dateSetAll = setAll;
  window.dateClearAll = clearAll;
  updateDateFilterUI({close: true}); 
}

function updateSelectedDates() {
    const list = document.getElementById("onAirDateDropdownList");
    selectedOnAirDates = Array.from(list.querySelectorAll(".date-chk:checked")).map(c => c.value);
    
    let activeSites = allSites.filter(site => {
        const date = siteCutoverMap[site];
        return date && selectedOnAirDates.includes(date);
    });
    // Only keep sites in selectedSites if their date is still active
    selectedSites = selectedSites.filter(site => activeSites.includes(site)); 
    
    // If no sites were selected, select all active sites by default
    if (selectedSites.length === 0 && selectedOnAirDates.length > 0) {
        selectedSites = [...activeSites];
    }
    
    updateDateFilterUI({close: false}); 
    setupSiteDropdown(); 
}

function updateDateFilterUI(options = {close: true}) {
    const btn = document.getElementById("onAirDateDropdownBtn");
    const span = document.getElementById("onAirDateBtnLabel");
    const list = document.getElementById("onAirDateDropdownList");
    
    span.textContent = selectedOnAirDates.length === 0 ? "No Dates Selected" : (selectedOnAirDates.length === allOnAirDates.length ? "All On-Air Dates" : `Selected (${selectedOnAirDates.length})`);
    
    list.querySelectorAll(".date-chk").forEach(c => c.checked = selectedOnAirDates.includes(c.value));
    
    if (options.close) {
        list.style.display = "none";
    } else {
        list.style.display = "block";
    }
}

// --- FILTER UI LOGIC (eNodeB NAME) ---

function setupSiteDropdown(){
  const list = document.getElementById("siteDropdownList");
  const btn = document.getElementById("siteDropdownBtn");
  list.innerHTML = "";

  let activeSites = allSites.filter(site => {
      const date = siteCutoverMap[site];
      return date && selectedOnAirDates.includes(date);
  });
  
  selectedSites = selectedSites.filter(site => activeSites.includes(site));
  
  const setAll = () => { 
    selectedSites = [...activeSites]; 
    updateSiteFilterUI({close: false}); 
    renderCharts();
  }; 

  const clearAll = () => { 
    selectedSites = []; 
    updateSiteFilterUI({close: false}); 
    renderCharts(); 
  };
  
  list.innerHTML += `<div onclick="window.siteSetAll()"><b>Select All (${activeSites.length})</b></div>`;
  list.innerHTML += `<div onclick="window.siteClearAll()"><b>Clear All</b></div>`;

  activeSites.forEach(site => {
    const d = document.createElement("div");
    const checked = selectedSites.includes(site) ? "checked" : ""; 
    d.innerHTML = `<input type='checkbox' value='${site}' class='site-chk' ${checked}> ${site}`;
    d.onclick = (e) => {
        if(e.target.tagName !== "INPUT") {
          const chk = d.querySelector("input");
          chk.checked = !chk.checked;
        }
        updateSelectedSites(); 
    };
    list.appendChild(d);
  });
  
  btn.onclick = () => list.style.display = list.style.display==="block" ? "none" : "block";

  window.siteSetAll = setAll;
  window.siteClearAll = clearAll;
  
  updateSiteFilterUI({close: true});
  renderCharts();
}

function updateSelectedSites() {
    const list = document.getElementById("siteDropdownList");
    selectedSites = Array.from(list.querySelectorAll(".site-chk:checked")).map(c => c.value);
    updateSiteFilterUI({close: false});
    renderCharts();
}

function updateSiteFilterUI(options = {close: true}) {
    const btn = document.getElementById("siteDropdownBtn");
    const span = document.getElementById("siteBtnLabel");
    const list = document.getElementById("siteDropdownList");
    
    let activeSites = allSites.filter(site => {
        const date = siteCutoverMap[site];
        return selectedOnAirDates.includes(date);
    });

    if(selectedSites.length === 0) span.textContent = "All Active Sites";
    else if(selectedSites.length === activeSites.length) span.textContent = `All Active Sites (${selectedSites.length})`;
    else if(selectedSites.length === 1) span.textContent = selectedSites[0];
    else span.textContent = `Selected (${selectedSites.length})`;

    list.querySelectorAll(".site-chk").forEach(c => c.checked = selectedSites.includes(c.value));
    
    if (options.close) {
        list.style.display = "none";
    } else {
        list.style.display = "block";
    }
}

// --- CHART RENDERING ---

let chartInstances = {}; // Store chart instances to destroy them later
function destroyCharts() {
    Object.values(chartInstances).forEach(chart => chart.destroy());
    chartInstances = {};
}

function renderCharts(){
  destroyCharts(); // Clear previous charts
  const container = document.getElementById("mainChartContainer");
  container.innerHTML = "";
  
  let kpisToShow = [];
  if(currentTab === "acceptance") kpisToShow = selectedKpis.acceptance;
  else if(currentTab === "monitoring") kpisToShow = selectedKpis.monitoring;
  else if(currentTab === "both") kpisToShow = [...selectedKpis.acceptance, ...selectedKpis.monitoring];

  let sitesFromDate = allSites.filter(site => {
      const date = siteCutoverMap[site];
      return selectedOnAirDates.includes(date);
  });

  let finalSiteList;
  if (selectedSites.length > 0) {
      finalSiteList = selectedSites;
  } else {
      finalSiteList = sitesFromDate;
  }
  
  let filteredData = allData.filter(d => finalSiteList.includes(d["eNodeB Name"]));

  const timeline = [...new Set(filteredData.map(d=>d["Date"]))].sort((a,b)=>{
    const [da,ma,ya]=a.split('/').map(Number);
    const [db,mb,yb]=b.split('/').map(Number);
    // Note: Assuming MM/DD/YYYY format for robustness. If DD/MM/YYYY, this needs adjustment.
    // Based on typical KPI dashboards, this sort is usually fine for daily data.
    return new Date(ya,ma-1,da)-new Date(yb,mb-1,db);
  });

  const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  const timelineLabels = timeline.map(d => {
      const [day, month] = d.split('/').map(Number);
      return `${day} ${monthNames[month - 1]}`; 
  });

  // Get the current style settings
  const style = chartStyles[selectedStyle];

  // 1. Map KPI data for each chart
  const chartDataMap = kpisToShow.map(kpi => {
      // Calculate the average KPI value for each date
      const dataPoints = timeline.map(date => {
          // Filter data for the current date
          const dateData = filteredData.filter(d => d["Date"] === date);
          // Extract all non-null values for the current KPI
          const values = dateData.map(d => d[kpi]).filter(v => v !== null && !isNaN(v));
          
          // Calculate the average (or sum for volume KPIs)
          if (values.length === 0) return null;
          
          // Sum up volumes, average percentages/rates
          if (kpi.includes("Volume") || kpi.includes("Traffic")) {
              return values.reduce((a, b) => a + b, 0);
          } else {
              // Average
              return values.reduce((a, b) => a + b, 0) / values.length;
          }
      });

      // Calculate Y-Axis bounds
      const allValues = dataPoints.filter(v => v !== null);
      const minVal = allValues.length > 0 ? Math.min(...allValues) : 0;
      const maxVal = allValues.length > 0 ? Math.max(...allValues) : 0;
      
      // Determine Ymax and step size for clean axis
      const isRateOrSuccess = kpi.includes("Rate") || kpi.includes("Success");
      const yMin = isRateOrSuccess ? 0 : (minVal > 0 ? 0 : minVal * 1.05);
      const yMaxRaw = isRateOrSuccess ? Math.max(100, maxVal * 1.05) : maxVal * 1.05;
      const yMax = roundUpToCleanScale(yMaxRaw);
      const stepSize = getIdealTickStep(yMax - yMin);
      
      return { kpi, dataPoints, yMin, yMax, stepSize, allValues };
  });

  // 2. Generate HTML and Chart Instances
  chartDataMap.forEach((chartData, index) => {
      // Create the container card
      const chartCard = document.createElement('div');
      chartCard.className = 'chart-card';
      chartCard.innerHTML = `
          <div class="chart-title">${chartData.kpi}</div>
          <div class="chart-container">
              <canvas id="chart-${index}"></canvas>
          </div>
      `;
      container.appendChild(chartCard);

      // Configure the Chart.js dataset based on selected style
      const datasetColor = `hsl(${(index * 36) % 360}, 65%, 45%)`;
      const chartConfig = {
          type: 'line',
          data: {
              labels: timelineLabels,
              datasets: [{
                  label: chartData.kpi,
                  data: chartData.dataPoints,
                  borderColor: datasetColor,
                  backgroundColor: style.fill ? hexToRgba(datasetColor, style.alpha) : 'transparent',
                  borderWidth: style.border,
                  pointRadius: style.pointRadius,
                  pointBackgroundColor: datasetColor,
                  tension: style.tension,
                  fill: style.fill,
                  stepped: style.stepped,
              }],
          },
          options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                  title: {
                      display: true,
                      text: chartData.kpi,
                      color: style.titleColor,
                      font: { size: 14, weight: '600' }
                  },
                  legend: { display: false }
              },
              scales: {
                  y: {
                      min: chartData.yMin,
                      max: chartData.yMax,
                      ticks: {
                          stepSize: chartData.stepSize,
                          color: style.titleColor,
                          font: { size: 11 }
                      },
                      grid: { color: style.gridColor },
                  },
                  x: {
                      ticks: {
                          color: style.titleColor,
                          maxRotation: 45, minRotation: 45,
                          font: { size: 10 }
                      },
                      grid: { display: false },
                  }
              }
          }
      };

      // Initialize the Chart object and store the instance
      chartInstances[`chart-${index}`] = new Chart(document.getElementById(`chart-${index}`), chartConfig);
  });
}

// --- PPT EXPORT FUNCTIONS ---

let pptChartData = []; // Data structure to hold all necessary chart details for export
let pptCanvasRefs = []; // Array of {canvas: HTMLCanvasElement, config: Chart.js config}
let previewModalOpen = false;


/**
 * Opens the preview modal and initializes the settings.
 */
function openPreview() {
    // 1. Collect all chart data required for PPT export
    const container = document.getElementById("mainChartContainer");
    pptChartData = Array.from(container.querySelectorAll('.chart-card')).map(card => {
        const title = card.querySelector('.chart-title').textContent;
        const canvas = card.querySelector('canvas');
        
        // Find the Chart.js instance associated with this canvas
        const chartId = canvas.id;
        const chartInstance = chartInstances[chartId];

        if (chartInstance) {
            // Clone the config. We use the config from the instance, but simplify the data
            const config = JSON.parse(JSON.stringify(chartInstance.config));
            // Remove animation/interaction options for static export
            if (config.options) {
                delete config.options.animation;
                delete config.options.responsive;
                delete config.options.maintainAspectRatio;
                config.options.plugins.tooltip = { enabled: false };
                config.options.plugins.legend = { display: false };
                
                // Set fixed size for PPT export rendering
                config.options.layout = {
                    padding: 10
                };
            }
            
            return {
                kpi: title,
                config: config,
                initialColor: config.data.datasets[0].borderColor,
                initialTitleColor: config.options.plugins.title.color
            };
        }
        return null;
    }).filter(d => d);

    if (pptChartData.length === 0) {
        alert("No charts visible to export. Please select data and KPIs.");
        return;
    }
    
    // 2. Initialize and open modal
    document.getElementById('previewModal').style.display = 'flex';
    previewModalOpen = true;
    
    // 3. Set default preview settings (e.g., 2 graphs/slide)
    updatePreviewSettings(2, chartExportColor, chartExportTitleColor);

    // Visually select the default options
    document.querySelectorAll('.graph-options button').forEach(btn => btn.classList.remove('active'));
    document.querySelector('.graph-options button[data-count="2"]').classList.add('active');
    
    document.querySelectorAll('.color-option').forEach(span => span.classList.remove('selected'));
    document.querySelector(`#lineColorOptions span[data-color="${chartExportColor}"]`).classList.add('selected');
    document.querySelector(`#titleColorOptions span[data-color="${chartExportTitleColor}"]`).classList.add('selected');

}

/**
 * Updates the preview settings (graphs per slide, colors) and re-renders the preview slides.
 */
function updatePreviewSettings(count, lineColor, titleColor) {
    graphsPerSlide = count;
    chartExportColor = lineColor;
    chartExportTitleColor = titleColor;

    // Update button/color selector visual state
    document.querySelectorAll('.graph-options button').forEach(btn => {
        btn.classList.toggle('active', parseInt(btn.dataset.count) === count);
    });
    document.querySelectorAll('#lineColorOptions .color-option').forEach(span => {
        span.classList.toggle('selected', span.dataset.color === lineColor);
    });
    document.querySelectorAll('#titleColorOptions .color-option').forEach(span => {
        span.classList.toggle('selected', span.dataset.color === titleColor);
    });

    renderPreviewSlides();
}

/**
 * Renders the image-based preview slides based on the current settings.
 */
function renderPreviewSlides() {
    const previewBody = document.getElementById("previewBody");
    previewBody.innerHTML = '';
    pptCanvasRefs = []; // Clear previous canvas refs

    for (let i = 0; i < pptChartData.length; i += graphsPerSlide) {
        const slideData = pptChartData.slice(i, i + graphsPerSlide);
        const slideIndex = Math.floor(i / graphsPerSlide) + 1;
        
        const slide = document.createElement('div');
        slide.className = 'preview-slide';
        slide.innerHTML = `<div class="preview-slide-title">Slide ${slideIndex}: ${slideData.map(d => d.kpi).join(', ')}</div>`;

        // Determine grid layout based on count
        let gridCols, gridRows;
        if (graphsPerSlide <= 2) {
            gridCols = 1;
            gridRows = graphsPerSlide;
        } else if (graphsPerSlide === 3 || graphsPerSlide === 4) {
            gridCols = 2;
            gridRows = Math.ceil(graphsPerSlide / 2);
        } else if (graphsPerSlide === 6) {
            gridCols = 3;
            gridRows = 2;
        } else { // Default to max 3x3
            gridCols = 3;
            gridRows = 3;
        }

        slide.querySelector('.preview-slide-title').style.color = chartExportTitleColor;
        const grid = document.createElement('div');
        grid.className = 'preview-grid';
        grid.style.gridTemplateColumns = `repeat(${gridCols}, 1fr)`;
        grid.style.gridTemplateRows = `repeat(${gridRows}, 1fr)`;

        slideData.forEach(data => {
            const imgBox = document.createElement('div');
            imgBox.className = 'preview-img-box';
            
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = 400; // Fixed width for preview rendering
            tempCanvas.height = 225; // Aspect ratio 16:9 
            
            // Apply current export theme to the chart config for preview
            const pptChartConfig = JSON.parse(JSON.stringify(data.config));
            pptChartConfig.data.datasets.forEach(dataset => {
                dataset.borderColor = chartExportColor;
                if (data.config.data.datasets[0].fill) {
                    dataset.backgroundColor = hexToRgba(chartExportColor, data.config.data.datasets[0].backgroundColor.split(',').pop().slice(0, -1));
                }
            });
            pptChartConfig.options.plugins.title.text = data.kpi;
            pptChartConfig.options.plugins.title.color = chartExportTitleColor;

            // Render chart to the temporary canvas
            const pptChart = new Chart(tempCanvas.getContext("2d"), pptChartConfig);
            
            // Wait for render, then capture image for HTML preview
            setTimeout(() => {
                const img = document.createElement('img');
                img.src = tempCanvas.toDataURL('image/png');
                imgBox.appendChild(img);
                imgBox.innerHTML += `<div class="preview-label" style="color: ${chartExportTitleColor}; font-size: 13px;">${data.kpi}</div>`;
                pptChart.destroy(); // Clean up chart instance
            }, 50);

            grid.appendChild(imgBox);

            // Store the data and config for the final PPT generation
            pptCanvasRefs.push({
                kpi: data.kpi,
                config: pptChartConfig,
                width: 1024, // High res for export
                height: 576
            });
        });

        slide.appendChild(grid);
        previewBody.appendChild(slide);
    }
}

/**
 * Closes the preview modal.
 */
function closePreview() {
    document.getElementById('previewModal').style.display = 'none';
    previewModalOpen = false;
}

/**
 * Generates and downloads the PPTX file.
 */
async function downloadPPT() {
    closePreview(); 
    const pres = new pptxgen();
    pres.layout = 'LAYOUT_16x9';

    // Temporary high-res canvas setup for export
    const exportCanvas = document.createElement('canvas');
    exportCanvas.width = 1024;
    exportCanvas.height = 576;
    const ctx = exportCanvas.getContext('2d');

    const totalCharts = pptCanvasRefs.length;

    for (let i = 0; i < totalCharts; i += graphsPerSlide) {
        const chartsOnSlide = pptCanvasRefs.slice(i, i + graphsPerSlide);
        const slide = pres.addSlide();
        
        // Determine grid layout for PPT slide
        let gridCols, gridRows, xPos, yPos, chartWidth, chartHeight;

        if (graphsPerSlide === 1) {
            gridCols = 1; gridRows = 1;
            xPos = 0.5; yPos = 0.5; chartWidth = 9.0; chartHeight = 5.0; // Large chart
        } else if (graphsPerSlide === 2) {
            gridCols = 1; gridRows = 2;
            xPos = 0.5; yPos = 0.5; chartWidth = 9.0; chartHeight = 2.5; // Two vertically stacked
        } else if (graphsPerSlide === 3 || graphsPerSlide === 4) {
            gridCols = 2; gridRows = 2;
            xPos = 0.25; yPos = 0.5; chartWidth = 4.5; chartHeight = 2.5; // 2x2 grid
        } else if (graphsPerSlide === 6) {
            gridCols = 3; gridRows = 2;
            xPos = 0.25; yPos = 0.5; chartWidth = 3.0; chartHeight = 2.5; // 3x2 grid
        } else { // Fallback 3x3
            gridCols = 3; gridRows = 3;
            xPos = 0.2; yPos = 0.5; chartWidth = 3.0; chartHeight = 1.6;
        }

        // Add slide title
        slide.addText(`KPI Trends - ${chartsOnSlide.map(c => c.kpi).join(' / ')}`, {
            x: 0.5, y: 0.2, w: '95%', h: 0.3,
            color: chartExportTitleColor.replace('#', ''),
            fontFace: 'Arial', fontSize: 18, bold: true
        });

        // Calculate positions dynamically for the grid
        const slideW = 10; 
        const slideH = 5.625; 
        const padding = 0.25;
        const totalW = slideW - padding * 2;
        const totalH = slideH - padding * 2;
        const cellW = totalW / gridCols;
        const cellH = totalH / gridRows;

        for (let j = 0; j < chartsOnSlide.length; j++) {
            const chartRef = chartsOnSlide[j];
            const row = Math.floor(j / gridCols);
            const col = j % gridCols;

            const finalX = padding + col * cellW;
            const finalY = padding + row * cellH + 0.5; // Offset for title

            // Render chart to the high-res canvas
            const pptChartConfig = chartRef.config;
            
            // Set chart title/legend options for export context
            pptChartConfig.options.plugins.title.display = true;
            pptChartConfig.options.plugins.title.text = chartRef.kpi;
            pptChartConfig.options.plugins.title.font.size = 20;

            // Reset canvas before drawing
            ctx.clearRect(0, 0, exportCanvas.width, exportCanvas.height);
            
            // Initialize the temporary chart
            const pptChart = new Chart(ctx, pptChartConfig);
            
            // CRITICAL FIX: Wait for the chart to fully render
            await new Promise(resolve => {
                requestAnimationFrame(() => {
                    setTimeout(resolve, 100); // 100ms delay to be absolutely safe
                });
            });

            // Capture image data
            const dataURL = exportCanvas.toDataURL('image/png', 1.0); // PNG for quality
            
            // Clean up immediately
            pptChart.destroy();

            // Add image to the slide
            slide.addImage({
                data: dataURL,
                x: finalX,
                y: finalY,
                w: cellW - 0.1, // Small margin
                h: cellH - 0.1,
                sizing: { type: 'contain', w: cellW - 0.1, h: cellH - 0.1 }
            });
        }
    }

    // Final download call
    pres.writeFile({ fileName: `LTE_KPI_Dashboard_${new Date().toISOString().slice(0, 10)}.pptx` });
}

// --- INITIALIZATION ---
document.addEventListener('DOMContentLoaded', () => {
    // Initial call to fetch data is in <body> tag: onload="fetchData()"
    // Populate the style drawer when the page is ready, regardless of the drawer state
    populateStyleOptions();
});
</script>
</body>
</html>
